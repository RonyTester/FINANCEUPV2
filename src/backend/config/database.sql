-- Create tables
CREATE TABLE IF NOT EXISTS transactions (
	id SERIAL PRIMARY KEY,
	description VARCHAR(255) NOT NULL,
	amount DECIMAL(10,2) NOT NULL,
	category VARCHAR(100) NOT NULL,
	date DATE NOT NULL,
	currency VARCHAR(3) DEFAULT 'BRL',
	created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS user_settings (
	id SERIAL PRIMARY KEY,
	currency VARCHAR(3) DEFAULT 'BRL',
	theme VARCHAR(10) DEFAULT 'light',
	created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
	updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS categories (
	id SERIAL PRIMARY KEY,
	name VARCHAR(100) NOT NULL,
	type VARCHAR(50) NOT NULL
);

-- Insert default categories
INSERT INTO categories (name, type) VALUES
	('Salário', 'income'),
	('Alimentação', 'expense'),
	('Transporte', 'expense'),
	('Moradia', 'expense'),
	('Lazer', 'expense'),
	('Saúde', 'expense'),
	('Educação', 'expense'),
	('Outros', 'expense');

-- Create test transaction
INSERT INTO transactions (description, amount, category, date) 
VALUES ('Teste inicial', 100.00, 'Outros', CURRENT_DATE);

-- Tabela de Despesas Fixas
CREATE TABLE IF NOT EXISTS fixed_expenses (
	id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
	user_id UUID REFERENCES auth.users NOT NULL,
	description TEXT NOT NULL,
	amount DECIMAL NOT NULL,
	category TEXT NOT NULL,
	due_day INTEGER NOT NULL,
	notification_days INTEGER DEFAULT 3,
	notes TEXT,
	created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
	updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
	
	CONSTRAINT positive_amount CHECK (amount > 0),
	CONSTRAINT valid_due_day CHECK (due_day BETWEEN 1 AND 31),
	CONSTRAINT valid_notification_days CHECK (notification_days >= 0)
);

-- Tabela de Pagamentos de Despesas Fixas
CREATE TABLE IF NOT EXISTS fixed_expense_payments (
	id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
	fixed_expense_id UUID REFERENCES fixed_expenses ON DELETE CASCADE NOT NULL,
	user_id UUID REFERENCES auth.users NOT NULL,
	amount DECIMAL NOT NULL,
	date DATE NOT NULL,
	payment_proof TEXT,
	notes TEXT,
	created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
	
	CONSTRAINT positive_payment_amount CHECK (amount > 0)
);

-- Habilitar RLS
ALTER TABLE fixed_expenses ENABLE ROW LEVEL SECURITY;
ALTER TABLE fixed_expense_payments ENABLE ROW LEVEL SECURITY;

-- Políticas para Despesas Fixas
CREATE POLICY "Visualizar próprias despesas fixas"
ON fixed_expenses FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Inserir próprias despesas fixas"
ON fixed_expenses FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Atualizar próprias despesas fixas"
ON fixed_expenses FOR UPDATE USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Deletar próprias despesas fixas"
ON fixed_expenses FOR DELETE
USING (auth.uid() = user_id);

-- Políticas para Pagamentos
CREATE POLICY "Visualizar próprios pagamentos"
ON fixed_expense_payments FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Inserir próprios pagamentos"
ON fixed_expense_payments FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Atualizar próprios pagamentos"
ON fixed_expense_payments FOR UPDATE USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Deletar próprios pagamentos"
ON fixed_expense_payments FOR DELETE
USING (auth.uid() = user_id);

-- Função para atualizar o updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
	new.updated_at = timezone('utc'::text, now());
	return new;
END;
$$ LANGUAGE plpgsql;

-- Trigger para atualizar o updated_at
CREATE TRIGGER update_fixed_expenses_updated_at
BEFORE UPDATE ON fixed_expenses
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Criar tabela de metas financeiras
CREATE TABLE IF NOT EXISTS financial_goals (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    target_amount DECIMAL(10,2) NOT NULL CHECK (target_amount > 0),
    deadline DATE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Criar índices para metas
CREATE INDEX IF NOT EXISTS financial_goals_user_id_idx ON financial_goals(user_id);
CREATE INDEX IF NOT EXISTS financial_goals_deadline_idx ON financial_goals(deadline);

-- Habilitar RLS para metas
ALTER TABLE financial_goals ENABLE ROW LEVEL SECURITY;

-- Criar políticas de segurança para metas
CREATE POLICY "Usuários podem ver suas próprias metas"
ON financial_goals FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Usuários podem criar suas próprias metas"
ON financial_goals FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Usuários podem atualizar suas próprias metas"
ON financial_goals FOR UPDATE
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Usuários podem deletar suas próprias metas"
ON financial_goals FOR DELETE
USING (auth.uid() = user_id);

-- Remover políticas existentes da tabela goal_contributions
DROP POLICY IF EXISTS "Usuários podem ver suas próprias contribuições" ON goal_contributions;
DROP POLICY IF EXISTS "Usuários podem inserir suas próprias contribuições" ON goal_contributions;
DROP POLICY IF EXISTS "Usuários podem atualizar suas próprias contribuições" ON goal_contributions;
DROP POLICY IF EXISTS "Usuários podem deletar suas próprias contribuições" ON goal_contributions;

-- Criar tabela de contribuições para metas
CREATE TABLE IF NOT EXISTS goal_contributions (
	id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	goal_id BIGINT REFERENCES financial_goals(id) ON DELETE CASCADE,
	user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
	amount DECIMAL(10,2) NOT NULL CHECK (amount > 0),
	date DATE NOT NULL DEFAULT CURRENT_DATE,
	notes TEXT,
	created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Criar índices para melhor performance
CREATE INDEX IF NOT EXISTS goal_contributions_goal_id_idx ON goal_contributions(goal_id);
CREATE INDEX IF NOT EXISTS goal_contributions_user_id_idx ON goal_contributions(user_id);
CREATE INDEX IF NOT EXISTS goal_contributions_date_idx ON goal_contributions(date);

-- Habilitar RLS (Row Level Security)
ALTER TABLE goal_contributions ENABLE ROW LEVEL SECURITY;

-- Criar políticas de segurança
CREATE POLICY "Usuários podem ver suas próprias contribuições"
ON goal_contributions FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Usuários podem inserir suas próprias contribuições"
ON goal_contributions FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Usuários podem atualizar suas próprias contribuições"
ON goal_contributions FOR UPDATE
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Usuários podem deletar suas próprias contribuições"
ON goal_contributions FOR DELETE
USING (auth.uid() = user_id);

-- Criar tabela de metas compartilhadas
CREATE TABLE IF NOT EXISTS shared_goals (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    creator_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    target_amount DECIMAL(10,2) NOT NULL CHECK (target_amount > 0),
    deadline DATE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Criar índices para metas compartilhadas
CREATE INDEX IF NOT EXISTS shared_goals_creator_id_idx ON shared_goals(creator_id);
CREATE INDEX IF NOT EXISTS shared_goals_deadline_idx ON shared_goals(deadline);

-- Habilitar RLS para metas compartilhadas
ALTER TABLE shared_goals ENABLE ROW LEVEL SECURITY;

-- Criar tabela de participantes das metas compartilhadas
CREATE TABLE IF NOT EXISTS shared_goal_participants (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    shared_goal_id BIGINT REFERENCES shared_goals(id) ON DELETE CASCADE NOT NULL,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'pending')),
    points INTEGER DEFAULT 0 NOT NULL,
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    UNIQUE(shared_goal_id, user_id)
);

-- Criar índices para participantes
CREATE INDEX IF NOT EXISTS shared_goal_participants_goal_id_idx ON shared_goal_participants(shared_goal_id);
CREATE INDEX IF NOT EXISTS shared_goal_participants_user_id_idx ON shared_goal_participants(user_id);

-- Habilitar RLS para participantes
ALTER TABLE shared_goal_participants ENABLE ROW LEVEL SECURITY;

-- Criar tabela de contribuições para metas compartilhadas
CREATE TABLE IF NOT EXISTS shared_goal_contributions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    shared_goal_id BIGINT REFERENCES shared_goals(id) ON DELETE CASCADE NOT NULL,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    amount DECIMAL(10,2) NOT NULL CHECK (amount > 0),
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    points_earned INTEGER DEFAULT 0 NOT NULL
);

-- Criar índices para contribuições de metas compartilhadas
CREATE INDEX IF NOT EXISTS shared_goal_contributions_goal_id_idx ON shared_goal_contributions(shared_goal_id);
CREATE INDEX IF NOT EXISTS shared_goal_contributions_user_id_idx ON shared_goal_contributions(user_id);
CREATE INDEX IF NOT EXISTS shared_goal_contributions_date_idx ON shared_goal_contributions(date);

-- Habilitar RLS para contribuições de metas compartilhadas
ALTER TABLE shared_goal_contributions ENABLE ROW LEVEL SECURITY;

-- Criar tabela de badges/conquistas
CREATE TABLE IF NOT EXISTS shared_goal_badges (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    shared_goal_id BIGINT REFERENCES shared_goals(id) ON DELETE CASCADE NOT NULL,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    badge_type VARCHAR(50) NOT NULL,
    earned_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    UNIQUE(shared_goal_id, user_id, badge_type)
);

-- Criar índices para badges
CREATE INDEX IF NOT EXISTS shared_goal_badges_goal_id_idx ON shared_goal_badges(shared_goal_id);
CREATE INDEX IF NOT EXISTS shared_goal_badges_user_id_idx ON shared_goal_badges(user_id);

-- Habilitar RLS para badges
ALTER TABLE shared_goal_badges ENABLE ROW LEVEL SECURITY;

-- Função de segurança definer para verificar permissões de metas compartilhadas
CREATE OR REPLACE FUNCTION check_shared_goal_access(goal_id bigint)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 
        FROM shared_goals sg
        LEFT JOIN shared_goal_participants sgp ON sg.id = sgp.shared_goal_id
        WHERE sg.id = goal_id
        AND (
            sg.creator_id = auth.uid() 
            OR sgp.user_id = auth.uid()
        )
    );
END;
$$;

-- Remover políticas existentes
DROP POLICY IF EXISTS "Usuários podem ver metas compartilhadas onde são participantes" ON shared_goals;
DROP POLICY IF EXISTS "Criadores podem inserir suas próprias metas compartilhadas" ON shared_goals;
DROP POLICY IF EXISTS "Criadores podem atualizar suas próprias metas compartilhadas" ON shared_goals;
DROP POLICY IF EXISTS "Criadores podem deletar suas próprias metas compartilhadas" ON shared_goals;

-- Novas políticas para shared_goals
CREATE POLICY "Usuários podem ver metas compartilhadas onde são participantes"
ON shared_goals FOR SELECT
USING (check_shared_goal_access(id));

CREATE POLICY "Criadores podem inserir suas próprias metas compartilhadas"
ON shared_goals FOR INSERT
WITH CHECK (auth.uid() = creator_id);

CREATE POLICY "Criadores podem atualizar suas próprias metas compartilhadas"
ON shared_goals FOR UPDATE
USING (auth.uid() = creator_id)
WITH CHECK (auth.uid() = creator_id);

CREATE POLICY "Criadores podem deletar suas próprias metas compartilhadas"
ON shared_goals FOR DELETE
USING (auth.uid() = creator_id);

-- Remover políticas existentes de participantes
DROP POLICY IF EXISTS "Usuários podem ver participantes de metas onde participam ou são criadores" ON shared_goal_participants;
DROP POLICY IF EXISTS "Criadores podem adicionar participantes às suas metas" ON shared_goal_participants;
DROP POLICY IF EXISTS "Usuários podem se adicionar como participantes" ON shared_goal_participants;
DROP POLICY IF EXISTS "Criadores podem atualizar status de participantes" ON shared_goal_participants;
DROP POLICY IF EXISTS "Criadores podem remover participantes" ON shared_goal_participants;

-- Novas políticas para shared_goal_participants
CREATE POLICY "Usuários podem ver participantes de metas onde participam"
ON shared_goal_participants FOR SELECT
USING (check_shared_goal_access(shared_goal_id));

CREATE POLICY "Criadores podem adicionar participantes às suas metas"
ON shared_goal_participants FOR INSERT
WITH CHECK (
    EXISTS (
        SELECT 1 FROM shared_goals
        WHERE id = shared_goal_id AND creator_id = auth.uid()
    )
);

CREATE POLICY "Usuários podem se adicionar como participantes"
ON shared_goal_participants FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Criadores podem atualizar status de participantes"
ON shared_goal_participants FOR UPDATE
USING (
    EXISTS (
        SELECT 1 FROM shared_goals
        WHERE id = shared_goal_id AND creator_id = auth.uid()
    )
)
WITH CHECK (
    EXISTS (
        SELECT 1 FROM shared_goals
        WHERE id = shared_goal_id AND creator_id = auth.uid()
    )
);

CREATE POLICY "Criadores podem remover participantes"
ON shared_goal_participants FOR DELETE
USING (
    EXISTS (
        SELECT 1 FROM shared_goals
        WHERE id = shared_goal_id AND creator_id = auth.uid()
    )
);

-- Remover políticas existentes de contribuições
DROP POLICY IF EXISTS "Usuários podem ver contribuições de metas onde participam" ON shared_goal_contributions;
DROP POLICY IF EXISTS "Usuários podem adicionar contribuições a metas onde participam" ON shared_goal_contributions;
DROP POLICY IF EXISTS "Usuários podem gerenciar suas próprias contribuições" ON shared_goal_contributions;
DROP POLICY IF EXISTS "Usuários podem deletar suas próprias contribuições" ON shared_goal_contributions;

-- Novas políticas para shared_goal_contributions
CREATE POLICY "Usuários podem ver contribuições de metas onde participam"
ON shared_goal_contributions FOR SELECT
USING (check_shared_goal_access(shared_goal_id));

CREATE POLICY "Usuários podem adicionar contribuições a metas onde participam"
ON shared_goal_contributions FOR INSERT
WITH CHECK (
    auth.uid() = user_id AND
    EXISTS (
        SELECT 1 FROM shared_goal_participants
        WHERE shared_goal_id = shared_goal_contributions.shared_goal_id 
        AND user_id = auth.uid() 
        AND status = 'active'
    )
);

CREATE POLICY "Usuários podem gerenciar suas próprias contribuições"
ON shared_goal_contributions FOR UPDATE
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Usuários podem deletar suas próprias contribuições"
ON shared_goal_contributions FOR DELETE
USING (auth.uid() = user_id);

-- Função para atualizar pontos de participante quando uma contribuição é feita
CREATE OR REPLACE FUNCTION update_participant_points()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE shared_goal_participants
    SET points = points + NEW.points_earned,
        updated_at = timezone('utc'::text, now())
    WHERE shared_goal_id = NEW.shared_goal_id AND user_id = NEW.user_id;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para atualizar pontos automaticamente
CREATE TRIGGER update_participant_points_on_contribution
AFTER INSERT ON shared_goal_contributions
FOR EACH ROW
EXECUTE FUNCTION update_participant_points();

-- Função para calcular pontos com base no valor da contribuição (10 pontos base + 1 ponto por R$100)
CREATE OR REPLACE FUNCTION calculate_contribution_points()
RETURNS TRIGGER AS $$
BEGIN
    -- 10 pontos base + 1 ponto por R$100 contribuídos
    NEW.points_earned = 10 + FLOOR(NEW.amount / 100);
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para calcular pontos antes de inserir contribuição
CREATE TRIGGER calculate_points_before_contribution
BEFORE INSERT ON shared_goal_contributions
FOR EACH ROW
EXECUTE FUNCTION calculate_contribution_points();

-- Função melhorada para buscar dados do usuário incluindo o display_name da tabela user_settings
CREATE OR REPLACE FUNCTION get_user_data_with_display_name(user_id uuid)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    user_data json;
    display_name_value text;
    user_email text;
BEGIN
    -- Buscar email do usuário
    SELECT email INTO user_email FROM auth.users WHERE id = user_id;
    
    -- Buscar o display_name da tabela user_settings
    SELECT us.display_name INTO display_name_value 
    FROM user_settings us 
    WHERE us.user_id = get_user_data_with_display_name.user_id;
    
    -- Log para verificar os valores
    RAISE NOTICE 'User ID: %, Email: %, Display Name: %', user_id, user_email, display_name_value;
    
    -- Montar o objeto JSON final
    SELECT json_build_object(
        'id', u.id,
        'email', u.email,
        'user_metadata', u.raw_user_meta_data,
        'display_name', COALESCE(display_name_value, u.email) -- Usar email como fallback
    ) INTO user_data
    FROM auth.users u
    WHERE u.id = user_id;
    
    RETURN user_data;
END;
$$;

-- Função para buscar usuário por email incluindo o display_name
CREATE OR REPLACE FUNCTION find_user_by_email_with_display_name(email_to_find TEXT)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    user_data json;
    user_id_value uuid;
    display_name_value text;
BEGIN
    -- Buscar ID do usuário pelo email
    SELECT id INTO user_id_value FROM auth.users WHERE email = email_to_find;
    
    -- Buscar o display_name da tabela user_settings
    SELECT us.display_name INTO display_name_value 
    FROM user_settings us 
    WHERE us.user_id = user_id_value;
    
    -- Log para verificar os valores
    RAISE NOTICE 'Email: %, User ID: %, Display Name: %', email_to_find, user_id_value, display_name_value;
    
    -- Montar o objeto JSON final
    SELECT json_build_object(
        'id', u.id,
        'email', u.email,
        'user_metadata', u.raw_user_meta_data,
        'display_name', COALESCE(display_name_value, u.email) -- Usar email como fallback
    ) INTO user_data
    FROM auth.users u
    WHERE u.email = email_to_find;
    
    RETURN user_data;
END;
$$;

-- Conceder acesso às funções para o role authenticated
GRANT EXECUTE ON FUNCTION get_user_data_with_display_name TO authenticated;
GRANT EXECUTE ON FUNCTION find_user_by_email_with_display_name TO authenticated;
